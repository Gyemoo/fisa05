## 오늘 진행한 내용
```
# 3. Subquery

USE fisa;
-- join으로도 다 할 수 있음
-- 먼저 조건에 맞는 값을 추려서 다른 테이블과 비교하기 때문에 속도면에서 우월합니다.alter


-- 1. 스칼라 서브쿼리 : 결과가 하나의 값으로 도출
-- 내부쿼리(10) -> 외부쿼리(emp에서 찾습니다) 동작
-- 내부쿼리에서는 외부쿼리의 FROM 절에 사용한 테이블을 참조할 수 있다
-- 외부쿼리에서는 내부쿼리에서 사용한 테이블을 참조할 수 없다
SELECT e.empno, e.ename, (SELECT d.dname FROM dept d WHERE e.deptno = d.deptno) as 부서명, d.deptno FROM emp e;
-- SELECT 절에는 스칼라 서브쿼리만 쓸 수 있습니다. 

-- 가장 emp 테이블에서 월급을 조금 받는 사람 
-- 서브쿼리(별도의 테이블로 간주) -> 서브쿼리의 결과를 사용하는 메인쿼리
SELECT * FROM emp ORDER BY sal ASC LIMIT 1;
SELECT ename FROM emp WHERE sal = (SELECT MIN(sal) FROM emp); 
SELECT ename, sal FROM emp WHERE (ename,sal) = (SELECT ename, sal FROM emp LIMIT 1);  -- 꼭 한개가 아니어도 튜플로 작동 가능

-- 부서가 accounting인 사람의 이름과 deptno를 emp, dept를 조인해서 확인해주세요.
SELECT e.ename, e.deptno, d.deptno, d.dname
FROM emp e, dept d
WHERE e.deptno = d.deptno AND d.dname ='ACCOUNTING';

SELECT e.ename, e.deptno
FROM emp e
WHERE e.deptno = (SELECT deptno FROM dept WHERE dname ='ACCOUNTING');
# 중복되는 서브쿼리를 맨 앞에 WITH 문으로 작성해 놓으면 몇번이고 별칭으로 불러 쓸 수 있습니다.

-- 2. FROM 절에서의 서브쿼리
-- 파생(derived) 서브쿼리
-- 꼭 별칭을 붙여서 외부 쿼리문에서는 별칭으로 사용합니다.
-- 서브쿼리가 반환하는 결과 집합을 하나의 테이블처럼 사용하는 쿼리문
-- 서브쿼리 안에서 사용해도 된다
-- FROM -> WHERE -> SELECT 


 -- join으로 해결
 -- emp 테이블에서 SMITH 직원명 검색해서 
 -- 어떤 부서인지 dept 테이블에서 찾아서 출력하기
SELECT d.dname FROM emp e JOIN dept d ON e.deptno = d.deptno WHERE e.ename = 'SMITH';

SELECT f.ename, d.dname
FROM dept d, (SELECT ename, emp.deptno FROM emp WHERE emp.ename= 'SMITH') f
WHERE f.ename = d.ename;
-- 직군이 MANAGER인 사람의 부서명, 부서이름, 이름, 직군을 출력해 주세요.
-- 메인쿼리 안에서 사용하는 서브쿼리의 쿼리문이 길어지면 또는 같은 쿼리를 여러 군데에 쓰게 되면
-- with 구문으로 맨 위로 빼서 가독성을 높일 수 있습니다.
WITH f as (SELECT ename, job, deptno FROM emp WHERE job = 'MANAGER'), g as (SELECT ename, job, deptno FROM emp WHERE job = 'MANAGER')
SELECT d.deptno, d.dname, f.ename, f.job, g.job FROM f, dept d, g
WHERE f.deptno = d.deptno;


-- 3. WHERE절의 서브쿼리
-- - 특정 데이터를 걸러내기 위한 일반 조건이나 조회 조건을 기술 
-- 비교 연산자 또는 ANY(~ 중 하나), SOME(하나라도 있으면), ALL(모두) 연산자를 사용하기도 함


-- subquery로 해결: SMITH 씨와 같은 부서에서 일하는 직원을 찾아주세요. SMITH씨는 빼고 
-- SMITH씨와 동일한 RESEARCH 부서 가진 모든 사원의 이름을 출력해보세요
SELECT * FROM emp WHERE deptno = (SELECT deptno FROM emp WHERE ename = 'SMITH') AND ename != 'SMITH';

-- ANY, SOME, ALL 이라는 조건을 사용해서 여러개의 결과값과 비교를 할 수도 있습니다.
-- ANY, SOME : 서브쿼리의 결과값 중 하나라도 만족하면 참
-- ALL : 서브쿼리의 결과값 모두 만족해야 참


-- (SMITH 씨랑 급여)가 같거나 더 많은 사원명과 급여를 검색해주세요
SELECT * FROM emp WHERE sal >= (SELECT sal FROM emp WHERE ename = 'SMITH') AND ename != 'SMITH' ORDER BY sal ASC;

-- deptno가 20번인 부서의 사람들 중 누구보다라도 많은 임금을 받는 모든 사람
-- ALL은 서브쿼리에서 나온 행별 결과모두와 값을 비교합니다.
SELECT e.ename, e.sal, e.deptno
FROM emp e
WHERE e.sal >= ALL(SELECT e.sal FROM emp e WHERE e.deptno=20);


-- deptno가 20번인 부서의 사람 각자 보다 많은 임금을 받는 모든 사람


-- 급여가 3000불 이상인 사원이 소속된 부서(10, 20)에 속한 사원이름, 급여 검색
SELECT * FROM emp WHERE deptno IN (SELECT deptno FROM emp WHERE sal >= 3000); -- 서브쿼리의 결과를 다시 메인쿼리에 사용하기 때문에 (10,20)

-- 얘는 왜 이럴까요? 
SELECT ename, sal, deptno FROM emp
WHERE deptno IN (SELECT -- (10, 20) 
    deptno
FROM
    emp 
WHERE
    sal >= 3000 AND deptno IN (10 , 20)); 
    
-- EXISTS 연산자는 메인쿼리 테이블의 값 중에서 서브쿼리의 결과 집합에
-- 존재하는 건이 있는지를 확인하는 역할: True / False 로 확인해서 True이면 결과를 리턴 
SELECT deptno FROM dept WHERE deptno=40;

SELECT e.ename, e.sal, e.deptno
FROM emp e
WHERE EXISTS (SELECT deptno FROM dept WHERE deptno=40); -- 그냥 뒤가 TRUE이면 출력, FALSE이면 없음 메인쿼리를 리턴할지 여부



-- EXISTS                  
-- 서브쿼리의 결과값이 존재하면 참

-- 각 부서별로 SAL가 가장 높은 사람은 누구일까요? 
SELECT 
    e.ename, e.deptno, e.sal
FROM
    emp e
WHERE
    e.sal = (SELECT 
            MAX(sal)
        FROM
            emp
        WHERE deptno = e.deptno);
-- 서브쿼리에 group by를 사용할 수 있습니다 
-- 이를 통해 group by로는 볼 수 없던 행별 정보를 서브쿼리로 추출한 테이블로 필터링해서 꺼낼 수 있다 
-- 서브쿼리에 group by를 사용할 수 있습니다 
-- 이를 통해 group by로는 볼 수 없던 행별 정보를 서브쿼리로 추출한 테이블로 필터링해서 꺼낼 수 있다 


-- IN 연산자는 여러개 컬럼의 값을 비교해서 꺼낼 수 있습니다
-- 단 순서가 맞아야 합니다 


-- job이 매니저인 사람이 어느 부서에만 있는지 서브쿼리를 통해 확인해보세요 
SELECT deptno, dname, loc
FROM dept
WHERE deptno IN (SELECT deptno
				FROM emp
				WHERE job='MANAGER');

-- 실습
USE box_office;
-- 2018년에 가장 많은 매출을 기록한 영화보다 더 많은 매출을 기록한 2019년도 영화를 검색해주세요    
SELECT * FROM movies WHERE revenue >= (SELECT max(revenue) FROM movies WHERE YEAR(release_date) = 2018) AND YEAR(release_date) = 2019;
-- 2018년 매출 TOP 5인 영화     
SELECT revenue FROM movies WHERE year(release_date) = 2018 ORDER BY 1 DESC LIMIT 5;

-- 중 어느 영화보다라도 더 큰 매출을 기록한 2019년 영화
WITH movies2018top5 as (SELECT revenue FROM movies WHERE year(release_date) = 2018 ORDER BY 1 DESC LIMIT 5)
SELECT title, revenue 
FROM movies
WHERE revenue >= ANY (SELECT revenue FROM movies2018top5)
	AND year(release_date) = 2019;
-- 2019년에 개봉한 국가의 영화 중 2018년에는 개봉하지 않았던 국가의 영화의 국가명, 영화명, 감독을 검색해주세요

SELECT m.country, m.title, m.director FROM movies m WHERE YEAR(release_date) = 2019 AND m.country NOT IN (SELECT DISTINCT country FROM movies WHERE YEAR(release_date) = 2018);

WITH f as (SELECT DISTINCT country FROM movies WHERE YEAR(release_date) = 2018)
SELECT m.country, m.title, m.director FROM movies m WHERE YEAR(release_date) = 2019 AND m.country NOT IN (SELECT country FROM f);

SELECT country, title, director 
FROM movies 
WHERE year(release_date) = 2019 AND country 
				NOT IN (SELECT DISTINCT country FROM movies WHERE year(release_date) = 2018);
                
-- EXISTS 는 T/F만 확인하므로 똑같은 동작인데 빠르게 동작합니다.

-- FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> DINTINCT -> ORDER BY -> LIMIT
-- 행이 많으면 속도가 느려지기 때문에 가장 행을 앞단에서 줄일 수 있는 순서
-- 테이블은 메인쿼리에서 먼저 가져옵니다 
-- 여기에 더해서 서브쿼리가 먼저 동작하기 때문에 서브쿼리를 최대한 간소한 결과가 나오도록 작성해주시면 좋습니다 


-- 어차피 동작도 서브쿼리부터 하고, 서브쿼리가 길어서 뭘 하는지 안 보인다면 
-- 따로 빼줘도 좋지 않을까요 
-- CTE, Common Table Expression FROM 절에서는 사용하기 위한 파생 테이블의 별명을 붙여서 사용할 수 있습니다 

 

# 두 개 속도 비교
-- cte: 2019년에 개봉한 영화 중에서 각 장르별로 관객 수가 가장 많거나 가장 적은 영화를 조회하기 
WITH stats AS (
    SELECT 
        movie_type, 
        MAX(audience) AS max_aud, 
        MIN(audience) AS min_aud
    FROM movies
    WHERE YEAR(release_date) = 2019
    GROUP BY movie_type
)
SELECT m.*
FROM movies m
JOIN stats s
  ON m.movie_type = s.movie_type
WHERE (m.audience = s.max_aud OR m.audience = s.min_aud)
  AND YEAR(m.release_date) = 2019;

-- subquery: 2019년에 개봉한 영화 중에서 각 장르별로 관객 수가 가장 많거나 가장 적은 영화를 조회하기 
SELECT *
FROM movies m
WHERE YEAR(m.release_date) = 2019
  AND (
    m.audience = (
      SELECT MAX(audience)
      FROM movies
      WHERE movie_type = m.movie_type AND YEAR(release_date) = 2019
    )
    OR
    m.audience = (
      SELECT MIN(audience)
      FROM movies
      WHERE movie_type = m.movie_type AND YEAR(release_date) = 2019
    )
  );

--   CTE 방식(첫 번째 쿼리)은
-- 집계 결과(stats)를 한 번만 계산해서 메모리에 올려놓고,
-- movies 테이블과 조인하여 결과를 빠르게 가져옵니다.

-- 서브쿼리 방식(두 번째 쿼리)은
-- movies 테이블의 각 행마다
-- MAX(audience), MIN(audience) 값을 다시 계산(서브쿼리 실행)합니다.
-- 즉, 행 수만큼 반복적으로 집계 쿼리가 실행되어 비효율적입니다.
-- 따라서 CTE 방식이 성능상 더 유리합니다.
```

## 오늘의 포인트
- 서브쿼리를 이용하여 리턴을 '값','컬럼','테이블'로 받아낼 수 있고, WHERE절에 비교로 쓸 수 있다.
- 튜플 형태로 두개 컬럼의 리턴값을 비교할 수도 있다.
- WITH 절을 이용하여 반복 실행값을 한번만 실행해줄 수 있다.