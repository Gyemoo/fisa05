## 오늘 배운 내용

```
{"coord":{"lon":126.9778,"lat":37.5683},"weather":[{"id":802,"main":"Clouds","description":"scattered clouds","icon":"03d"}],"base":"stations","main":{"temp":30.76,"feels_like":36.96,"temp_min":30.76,"temp_max":30.76,"pressure":1000,"humidity":70,"sea_level":1000,"grnd_level":990},"visibility":10000,"wind":{"speed":5.66,"deg":280},"clouds":{"all":40},"dt":1754295646,"sys":{"type":1,"id":8105,"country":"KR","sunrise":1754253495,"sunset":1754303887},"timezone":32400,"id":1835848,"name":"Seoul","cod":200}{"cod":401, "message": "Invalid API key. Please see https://openweathermap.org/faq#error401 for more info."}
```
- cron은 환경변수를 읽어올 수 없어서 API키를 환경변수로 저장했더니 에러가 뜸

```
# weather.sh
#!/bin/bash

set -a      
. /home/user01/.bashrc
set +a

echo $WEATHER >> /home/user01/backup/api_key.log
curl "http://api.openweathermap.org/data/2.5/weather?q=Seoul,kr&appid=$WEATHER&units=metric" >> /tmp/weather.json

exit 0;
```

```
* * * * * df -h > /tmp/resultfile.log 2> /tmp/resulterror.log
*/2 * * * * bash /home/user01/backup/weather.sh
```

```
$ alias ls="ls -F"
```

- 리눅스에서 특정 명령어를 alias로 만들어 조건을 붙여 쓸 수 있다.

```
1stVar=value    # X  숫자로 변수명이 시작됨
my-Name=Yeonji  # X - 변수명에 하이픈(-)이 포함됨
myName='Yeonji $Kim $(date)'  # O  작은따옴표 - 명령어 치환 비허용
myName="Yeonji $Kim $(date)" # O  큰따옴표 - 명령어 치환 허용
myName=Yeonji   # O
```

- 환경변수와 로컬변수

```
#!/bin/sh

# 셸에서의 숫자 계산

num1=100

# num1 변수는 그냥 문자열로 인식됩니다
num2=$num1 + 200
echo $num2

# `(백틱)과 expr 이라는 연산자를 통해 num1을 숫자로 인식할 수 있습니다.
num3=`expr $num1 + 200`
echo $num3

# 괄호를 두번 사용하여 직접 더할 수 있습니다.
sum=$(($num1 + 200))
echo $sum

# 괄호 안에 expr 연산자를 사용하여서도 직접 연산할 수 있습니다.
sum1=$(expr $num1 - 200)
echo $sum1

# 이스케이핑문자(리눅스에서는 메타문자라고도 부릅니다)를 통해 ()와 *가 문자열이 아닌
# 연산 부호로 인식되게 합니다.
num4=`expr  \(  $num1 + 200  \) / 10  \*  2`
echo $num4
```

- 셸 스크립트에서 숫자 사용 시 expr로 실행해줘야 함

```
sudo apt install ncal
cal 1> a.txt  →  cat a.txt
df  -h >> b.txt     →   cat b.txt
who    >  a.txt    →   cat   a.txt
who   >>   b.txt     →   cat   b.txt # 원래 b.txt 내용 아래에 해당 내용 출력
find    /   -user  유저명  # 권한이 없으므로 에러 - 이럴 때 에러 리다이렉션 사용 
find    /   -user  유저명     >    c.txt # 이러면 정상 메시지만 c.txt에 출력됨(1은 생략 가능)
find    /   -user  유저명     2>    c.txt # 이러면 에러 메시지만 c.txt에 출력됨 
find    /  -user atangi 2> /dev/null #  에러를 화면에 출력하고 싶지 않다면 : null device로 출력함.
find    /  -user atangi 2>  c.txt > normal.txt 
# 에러는 c.txt, 정상메시지는 normal.txt에 redirect : 화면에는 아무것도 출력되지 않음

# 에러 / 정상 관련 명령어 합치기
find    /   -user  유저명 >  total   2>&1 
find    /   -user  유저명 &>  total2 #  표준 출력과 표준 에러를 한꺼번에 리다이렉션하는 bash용 축약 문법

# 화면에 출력하고 싶지 않다면: null device로 출력하면 됩니다. 
find / -user 유저명 > /dev/null 2> c.txt
```

- 1번은 정상 출력, 2번은 오류 출력

- /dev/null로 쓰레기통, /tmp로 모든 유저에서 참조

```
# if_and_file.sh

#!/bin/sh

echo "내용을 보고 싶은 파일명을 입력하세요."
read fname

# and는 ‘-a’ 또는 ‘&&’를 사용, or는 ‘-o’ 또는 ‘||’를 사용합니다.
if [ -? $fname ] ?? [ -? $fname ] ; then
    head -5 $fname
else
    echo "파일이 없거나, 크기가 0입니다."
fi
exit 0
```

- if문 사용가능

```
#for.sh

#!/bin/sh

for fname in $(ls *.sh)
do
    echo "--------$fname-------"
    head -3 $fname
done
exit 0
# 현재 디렉터리에 있는 셸 스크립트 파일(*.sh)의 파일명과 앞 3줄을 출력하는 프로그램
```

- 반복문도 사용 가능

- cron으로 주기적으로 실행 가능(최대 분단위)