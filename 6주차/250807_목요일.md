## 오늘 진행한 내용

```
# Welcome to the Dev Tools Console!
#
# You can use Console to explore the Elasticsearch API. See the Elasticsearch API reference to learn more:
# https://www.elastic.co/guide/en/elasticsearch/reference/current/rest-apis.html
#
# Here are a few examples to get you started.


# Create an index
# 내용을 담아서 보내는 api의 호출방식
POST my-index

PUT /my-index3

GET my-index3


# Add a document to my-index

# 날씨, 오늘 날씨, 8월 6일 날씨
# "날씨", "오늘 날씨", "8월 6일 날씨" - 키워드
# 
# 인덱스명/_doc
POST /my-index3/_doc
{
    "id": "park_rocky-mountain",
    "title": "Rocky Mountain",
    "description": "Bisected north to south by the Continental Divide, this portion of the Rockies has ecosystems varying from over 150 riparian lakes to montane and subalpine forests to treeless alpine tundra."
}

# document 번호를 직접 지정해서 값을 넘기거나 수정할 때
PUT /my-index/_doc/1
{
    "id": "park_rocky-mountain2",
    "description": "Bisected north to south by the Continental Divide, this portion of the Rockies has ecosystems varying from over 150 riparian lakes to montane and subalpine forests to treeless alpine tundra.",
    "document_number": 2,
    "tags": ["rocky", "true", "3.14", "2"]
}

GET /my-index/_search

# PUT - 내용 전체에 대한 수정
PUT my-index/_doc/12
{
    "id": "park_rocky-mountain2",
    "description": "Bisected north to south by the Continental Divide, this portion of the Rockies has ecosystems varying from over 150 riparian lakes to montane and subalpine forests to treeless alpine tundra.",
    "document_number": 3, //문서 안에도 사용 가능한 주석
    "tags": ["rocky", "true", "3.14", "2"]
}
# PATCH - 내용 일부에 대한 수정을 의미하지만 ES에는 PATCH가 없음
POST my-index/_update/1
{
  "doc":
  {  "document_number": 4}
}

# Perform a search in my-index
GET /my-index/_search?q="rocky mountain"

GET /my-index/_search

# 세밀한 조건 없이 특정 필드에서 값을 찾고자 할 때는
GET /my-index/_search?q="tundra"
GET /my-index/_search?q=id:"mountain2"

# 검색시에도 본문을 담아서 요청을 보냈다면 GET / POST를 사용 가능합니다.
POST /my-index/_search
{
    "query" : {
        "match": {
          "id": "mountain2"
        }
    }
}

# 문서 하나를 삭제
DELETE /my-index/_doc/1

DELETE /my-index


# 자료형을 고정해서 index를 만들기
# text: 들어오는 문자열을 검색하기 좋게 쪼개서 저장합니다.
# keyword: 들어오는 문자열을 통으로 저장합니다.
PUT /my-index
{
   "mappings": {
      "properties": {
        "address": {
          "type": "text"
        },
        "age": {
          "type": "long"
        },
        "name": {
          "type": "keyword"
        }
      }
   }
}

GET /my-index

PUT /my-index/_doc/1
{
    "name":"kim YEONji",
    "age":23,
    "address":"서울시 강동구 상일동"
}

GET /my-index


# name 필드는 keyword 자료형이므로 통째로 색인 - 완전일치 아니면 검색 불가
GET /my-index/_search?q="KIM"


# address 필드는 text 자료형이므로 우리가 정한 조건에 맞춰서(단어, 띄어쓰기 단위로) 색인 - 일부일치 검색 불가
GET /my-index/_search?q="서울시"

POST _analyze
{
    "analyzer": "standard",
    "text": "hello, World. Today is Wednesday. hahaha! I'm sad, happiness is over there"
}

DELETE my-index
DELETE my-index2
DELETE my-index3

POST my-index/_doc
{
  "name" : "김연지", // text
  "age" : 39, // long
  "height" : 170.1, // float
  "hobby" : ["책보기", "누워있기", "3333"], // 복합자료형의 자료형이 아닌 해당 필드의 값들을 자료형으로 관리함, 모두 같은 자료형만 넣을 수 있음
  "is_human" : true, // boolean
  "date" : 1754526456, // long - 별도로 mapping해주지 않으면 숫자
  "birth" : "1987-03-16" // date
}

GET my-index/_search?q=hobby:"책보기"
// 복합자료형도 심플자료형과 같은 방식으로 검색(하나씩 쪼개서 검색 가능)
GET my-index

POST woorifisa/_doc
{
  "students" : 
  {"name" : "신짱구", // student.name - 내부적으로 평탄화
  "age" : 5} // student.age
}

GET woorifisa/_search?q=students.name:"신짱구"

// 부득이하게 students 필드를 doc 안의 doc로써 관리해야 하는 경우 
PUT woorifisa_nested_test
{
  "mappings": {
    "properties": {
      "student": {
        "type": "nested",
        "properties": {
          "name": {
            "type": "keyword"
          },
          "age": {
            "type": "long"
          }
        }
      }
    }
  }
}

POST woorifisa_nested_test/_doc/
{
  "student": {    
    "name": "신짱구",  
    "age": 5
  }
}

GET woorifisa_nested_test/_search?q=students.name:"신짱구" // 안나옴

GET woorifisa_nested_test/_search // 인덱스 안의 mapping이 nested라면 이런식으로
{
  "query" : {
    "nested" : {
      "path" : "student",
      "query": {
        "match": {
          "student.name": "신짱구"
        }
      }
    }
  }
}

PUT my-index/_doc/11
{
  "name": ["신짱구","신짱아","맹구"]
}


PUT time-example
{
  "mappings": {
    "properties": {
      "dateField" :
      {"type" : "date",
       "format": "strict_date_time || epoch_millis || epoch_second"
      }
    }
  }
}

POST time-example/_doc
{
  "dateField" : "2025-08-03" // 2025-8-7-10-19
}

POST time-example/_doc
{
  "dateField" : "2025-08-03T00:25:30Z" // 2025-8-7-10-19
}

POST time-example/_doc
{
  "dateField" :17545268530000 // 2025-8-7-10-19
}

POST time-example/_doc
{
  "dateField" :1754526853 // 2025-8-7-10-19
}

GET time-example/_search


GET my-index
POST my-index/_doc
{
  "age" : 40.6 // 정수 자료형의 자리에 실수
}

POST my-index/_search

POST my-index/_doc
{
  "height" : 173 // 실수 자료형의 자리에 정수
}

// 색인을 위한 데이터와 조회를 위한 데이터가 따로 관리되기 때문에 일부 형변환에 대해 허용해주는 것처럼 보입니다. 자체적으로 보정을 해서 색인을 하기 때문에

GET my-index/_search?q=40
GET my-index/_search?q=173

GET my-index/_search // 일부 문서를 특정 조건으로 조회할 때
{
  "query" : {
    "match" : {
      "hobby" : "책보기"
    }
  }
}


POST _bulk
{"index": {"_index" : "test", "_id":"1"}}{"account_number":1,"balance":39225,"firstname":"Amber","lastname":"Duke","age":32,"gender":"M","address":"880 Holmes Lane","employer":"Pyrami","email":"amberduke@pyrami.com","city":"Brogan","state":"IL"}{"index":{"_index" : "test", "_id":"6"}}{"account_number":6,"balance":5686,"firstname":"Hattie","lastname":"Bond","age":36,"gender":"M","address":"671 Bristol Street","employer":"Netagy","email":"hattiebond@netagy.com","city":"Dante","state":"TN"}
{"index":{"_index" : "test", "_id":"13"}}{"account_number":13,"balance":32838,"firstname":"Nanette","lastname":"Bates","age":28,"gender":"F","address":"789 Madison Street","employer":"Quility","email":"nanettebates@quility.com","city":"Nogal","state":"VA"}
{"index":{"_index" : "test", "_id":"18"}}{"account_number":18,"balance":4180,"firstname":"Dale","lastname":"Adams","age":33,"gender":"M","address":"467 Hutchinson Court","employer":"Boink","email":"daleadams@boink.com","city":"Orick","state":"MD"}
{"index":{"_index" : "test", "_id":"20"}}{"account_number":20,"balance":16418,"firstname":"Elinor","lastname":"Ratliff","age":36,"gender":"M","address":"282 Kings Place","employer":"Scentric","email":"elinorratliff@scentric.com","city":"Ribera","state":"WA"}
{"index":{"_index" : "test", "_id":"25"}}{"account_number":25,"balance":40540,"firstname":"Virginia","lastname":"Ayala","age":39,"gender":"F","address":"171 Putnam Avenue","employer":"Filodyne","email":"virginiaayala@filodyne.com","city":"Nicholson","state":"PA"}
{"index":{"_index" : "test", "_id":"32"}}{"account_number":32,"balance":48086,"firstname":"Dillard","lastname":"Mcpherson","age":34,"gender":"F","address":"702 Quentin Street","employer":"Quailcom","email":"dillardmcpherson@quailcom.com","city":"Veguita","state":"IN"}

GET test/_mapping
GET test/_settings

# match_all 모든 문서 검색 - 생략
GET test/_search
{
  "query" : {
    "match_all" : {}
  }
}

#match : text 타입 자료형 필드에서 일치하는 조건 탐색 - 대소문자 구분 X

GET test/_search
{
  "query" :{
    "match":{
      "address" : "holmes"
    }
  }
}

#query_string : 주소줄에 달아보내는것과 같은 방식 동작 - * 모든 문자, ? 한글자
GET test/_search
{
  "query" :{
    "query_string":{
      "default_field": "address",
      "query" : "h*"
    }
  }
}


# 순서대로 값을 탐색 
# 상암 맛집, 상암 0동 맛집, 상암 mbc 근처 맛집
GET test/_search
{
  "query": {
    "match_phrase": {
      "address":
      { 
        "query" : "880 Lane", // 880 _ _ Lane
        "slop" : 2 // slop 
      }
    }
  }
}



# or 조건 탐색 match 구문 안에서 띄어쓰기
# 검색순위에 가장 많은 키워드가 걸린 document부터 등장
GET test/_search
{
  "query": {
    "match": {
      "address": "702 street"
    }
  }
}

# AND 조건
GET test/_search
{
  "query": {
    "match": {
      "address":{
        "query" : "702 street",
        "operator" : "and"
      } 
    }
  }
}

# dillard 라는 값을 여러 필드에서 조회
GET test/_search?q=dillard

# q? url 전달과 query_string
GET test/_search
{
  "query" : {
    "query_string":{
      "fields":["firstname","lastname"],
      "query":"d*"
    }
  }
}


# bool - must/must_not/should/filter
# 1. must : 꼭 포함
GET test/_search
{
  "query" : {
    "match" :{
      "firstname": "dillard"
    }
  }
}

# must - dillard이면서 must_not - 나이가 34살이 아닌 사람
GET test/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "firstname": "dillard"
          }
        }
      ],
      "must_not": [
        {
          "match": {
            "age": 34
          }
        }
      ]
    }
  }
}


GET test/_search
{
  "query":{
    "match":{
      "state" : "PA"
    }
  }
}



# state가 PA 이면서 address가 street이 아닌 사람

GET test/_search
{
  "query": {
    "bool": {
      "must": {
        "match": {
          "state": "PA"
        }
      },
      "must_not": {
        "match": {
          "address": "street"
        }
      }
    }
  }
}



# state가 PA 이면서 address가 street이 아닌 사람

GET test/_search
{
  "query": {
    "bool": {
      "must": {
        "match": {
          "state": "PA"
        }
      },
      "should": {
        "match": {
          "address": "avenue"
        }
      }
    }
  }
}

# should : 강제가 아니라 포함되는 조건에 높은 점수를 부여하도록 조정
# address : street에 살면서 firstname이 dillard인 사람

GET test/_search
{
  "query": {
    "bool": {
      "must": {
        "match": {
          "firstname": "dillard"
        }
      },
      "should": {
        "match": {
          "address": "street"
        }
      }
    }
  }
}

# must address:street에 살면서 
# must firstname이 dillard인 사람을 찾아주세요. 
GET test/_search
{
  "query": {
    "match": {
      "address": "street"
    }
  }
}

GET test/_search
{
  "query": {
    "match": {
      "firstname": "dillard"
    }
  }
}

GET test/_search
{
  "query": {
    "bool": {
      "must": [
        { "match" : {
          "address": "street"
        }},
         {"match":{
          "firstname": "dillard"
        }}
      ]
    }
  }
}

# street에 살면서 must_not - dillard는 아닌 사람 
GET test/_search
{
  "query": {
    "bool": {
      "must": [
        { "match" : {
          "address": "street"
        }}
      ],
      "must_not": [
         {"match":{
          "firstname": "dillard"
        }}
      ]
    }
  }
}


# street에 살면서 dillard는 가중치 부여  
GET test/_search
{
  "query": {
    "bool": {
      "must": [
        { "match" : {
          "address": "street"
        }}
      ],
      "should": [
         {"match":{
          "firstname": "dillard"
        }}
      ]
    }
  }
}

// 4. filter: must와 같은 결과를 보여줍니다. 하지만 filter 이하의 조건은 점수를 계산하지 않습니다. 그래서 데이터가 많은 경우 약간 빠릅니다. 
GET test/_search
{
  "query": {
    "bool": {
      "must": [
        { "match" : {
          "address": "street"
        }}
      ],
      "filter": [
         {"match":{
          "firstname": "dillard"
        }}
      ]
    }
  }
}

# balance가 30000 달러를 넘는 사람
# >= range 키워드로 탐색
# gt, lt, gte, lte, must, must_not
GET test/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "range": {
            "balance": {
              "gte": 32838, // 32838 <=x
              "lte": 42000  // x>=42000
            }
          }
        }
      ]
    }
  }
}


GET test/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "balance": 32838
          }
        }
      ]
    }
  }
}


POST my_bulk/_bulk
{"index":{"_id":1}}{"message":"죽는 날까지 하늘을 우러러 한 점 부끄럼이 없기를"}
{"index":{"_id":2}}{"message":"죽는 날까지 하늘을 우러러 한 점 부끄럼이 없기를, 잎새에 이는 바람에도 나는 괴로워했다"}
{"index":{"_id":3}}{"message":"죽는 날까지 하늘을 우러러 한 점 부끄럼이 없기를,\n 잎새에 이는 바람에도 너는 괴로워했다"}
{"index":{"_id":4}}{"message":"chrome google Chrome Google"}
{"index":{"_id":5}}{"message":"하늘사 Google Chrome"}
{"index":{"_id":6}}{"message":"pink"}
{"index":{"_id":7}}{"message":"pinkRed"}
{"index":{"_id":8}}{"message":"pink red blue"}
{"index":{"_id":9}}{"message":"pink red blue black"}
{"index":{"_id":10}}{"message":"pink red blue black green"}
{"index":{"_id":11}}{"message":"pink blue red black green"}
{"index":{"_id":12}}{"message":"pink pink"}


# 실습. my_bulk 에서 수행
GET my_bulk/_search // my_bulk 잘 들어갔나 확인
# match 
# -1. match_all(전부)
# -2. match: 단어 일치(기본operator: OR)
# -3. match_phrase: 순서대로 단어 일치 (slop으로 사잇값 지정)
# -4. query_string: 정규식 등 활용 가능 

# bool 
# -1. must : 포함(AND) [  ] 안에 몇개든지 조건 더할 수 있음
# -2. must_not : 불포함(NOT)
# -3. should : 가중치 부여(권유)
# -4. filter: must처럼 특정 조건을 포함하되 점수계산을 하지 않아서 빠르다. 

# 1. google 이라는 단어가 들어간 모든 문서를 검색해보세요
# match는 소문자 대문자 안가리고 검색을 해줍니다 
# 띄어쓰기가 OR로 취급됩니다

GET my_bulk/_search?q=google // 그냥 모든 문서에서 찾을때는 쿼리스트링으로

# 2. Chrome Google이 순서대로 들어있는 문서를 검색
GET my_bulk/_search
{
  "query":
  {
    "match_phrase":
    {
      "message":{
        "query": "Chrome Google"
      }
    }
  }
}

# 3. pink가 들어가되 blue가 같이 들어있는 경우 가중치 부여 (blue가 없는 경우는 후순위로 검색)
GET my_bulk/_search
{
  "query":
  {
    "bool":
    {
      "must":
      {
        "match":
        {"message":"pink"}
      },
      "should":
      {
        "match":
        {"message":"blue"}
      }
    }
  }
}

# 4. pink가 들어가되 blue가 같이 들어있는 경우 SCORE는 바뀌지 않되 해당 조건을 검색
GET my_bulk/_search
{
  "query":
  {
    "bool":
    {
      "must":
      {
        "match":
        {"message":"pink"}
      },
      "filter":
      {
        "match":
        {"message":"blue"}
      }
    }
  }
}


# 5. "하늘사"라는 단어가 있거나 없거나 상관 없이 google, chrome이 들어간 경우 검색
GET my_bulk/_search
{
  "query":
  {
    "bool":
    {
      "must":
      [
        {"match":
          {
            "message":"google"
          }
        },
        {"match":
          {
            "message":"chrome"
          }
        }
      ]
    }
  }
}
# 6. 하늘사는 안들어가고 chrome은 들어가는 다큐먼트를 검색
GET my_bulk/_search
{
  "query":
  {
    "bool":
    {
      "must":
      {
        "match":
        {
          "message":"chrome"
        }
      },
      "must_not":
      {
        "match":
        {
          "message":"하늘사"
        }
      }
    }
  }
}
# 6-1. 하늘사가 없어서 점수를 부여하고 싶으면 bool 
GET my_bulk/_search
{
  "query":
  {
    "bool":
    {
      "should":
      [
        {
          "bool":
          {
            "must_not":
            {
              "match":
              {
                "message":"하늘사"
              }
            }
          }
        }
      ],
      "must":
      {
        "match":
        {
          "message":"chrome"
        }
      }
    }
  }
}
# 6-2. 하늘사가 없다고 거기에 점수는 부여하지 않고 싶으면 filter

GET my_bulk/_search
{
  "query":
  {
    "bool":
    {
      "filter":
      [
        {
          "bool":
          {
            "must_not":
            {
              "match":
              {
                "message":"하늘사"
              }
            }
          }
        }
      ],
      "must":
      {
        "match":
        {
          "message":"chrome"
        }
      }
    }
  }
}


POST _analyze
{
  "analyzer" : "standard",
  "text" : "Hello, HELLO, World!"
}

POST _analyze
{
  "analyzer": "fingerprint",
  "text": "Yes yes, Gödel said this sentence is consistent and."
}

POST _analyze
{
  "analyzer": "whitespace",
  "text": "Yes yes, Gödel said this sentence is consistent and."
}


# html strip 캐릭터필드 적용
POST _analyze
{
  "char_filter": ["html_strip"],
  "text": "<p>I&apos;m so <b>happy</b>!</p>"
}



PUT /my-index-000001
{
  "settings": {
    "analysis": {
      "analyzer": {
        "my_analyzer": {
          "tokenizer": "standard",
          "char_filter": [
            "my_mappings_char_filter"
          ]
        }
      },
      "char_filter": {
        "my_mappings_char_filter": {
          "type": "mapping",
          "mappings": [
            ":) => _happy_",
            ":( => _sad_"
          ]
        }
      }
    }
  }
}

GET /my-index-000001/_analyze
{
  "tokenizer": "keyword",
  "char_filter": [ "my_mappings_char_filter" ],
  "text": "I'm delighted about it :)"
}



POST _analyze
{
  "tokenizer": "keyword", 
  "text": "Hello, HELLO, World!"
}

POST _analyze
{
  "tokenizer": {
    "type": "ngram",
    "min_gram": 3,
    "max_gram": 4
  },
  "text": "Hello, World!"
}

# "o, W"나 ", Wo"나 "ld!"처럼 공백 문자나 문장 부호가 포함되어 사실상 의미가 없는 토큰도 포함되는데... 
# token_chars라는 속성을 사용한다면?

POST _analyze
{
  "tokenizer": {
    "type": "ngram",
    "min_gram": 3,
    "max_gram": 4,
    "token_chars": ["letter"]
  },
  "text": "Hello, World!"
}

# edge_ngram
# 모든 토큰의 시작 글자를 단어의 시작 글자로 고정시켜서 생성 
# - llo 같은 토큰은 생성되지 않음
POST _analyze
{
  "tokenizer": {
    "type": "edge_ngram",
    "min_gram": 3,
    "max_gram": 4,
    "token_chars": ["letter"]
  },
  "text": "Hello, World!"
}



# config/analysis/my-synonym.txt
pc, mac, computer, ibm, labtop, notebook
서울시, 서울특별시, 서울, 서울 특별시
경상북도 => 경북
세종시, 세종특별시 => 세종

"analyzer": {
  "my_analyzer": {
    "type": "custom",
    "tokenizer": "standard",
    "filter": ["stemmer", "synonym"]
  }
}

PUT /my_synonym_index
{
  "settings": {
    "analysis": {
     "filter": {
        "synonym_filter": {
          "type": "synonym",
          "synonyms_path": "analysis/my-synonym.txt"
        }
      },
      "analyzer": {
        "my_synonym_analyzer": {
          "tokenizer": "standard",
          "filter": [
            "lowercase",
            "synonym_filter"
          ]
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "title": {
        "type": "text", // title에 들어있는
        "analyzer": "my_synonym_analyzer"
      }
    }
  }
}

POST /my_synonym_index/_analyze
{
  "analyzer":"my_synonym_analyzer",
  "text" : "I bought a pc, mac, ibm, in 서울시 세종시 경상북도"
}

DELETE /my_synonym_index



### 노멀라이저 -> keyword에 필드에 적용


PUT normalizer_test
{
  "settings": {
    "analysis": {
      "normalizer": {
        "my_normalizer": {
          "type": "custom",
          "char_filter": [],
          "filter": [
            "asciifolding",
            "uppercase"
          ]
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "myNormalizerKeyword": {
        "type": "keyword",
        "normalizer": "my_normalizer"
      },
      "lowercaseKeyword": {
        "type": "keyword",
        "normalizer": "lowercase"
      },
      "defaultKeyword": {
        "type": "keyword"
      }
    }
  }
}


GET normalizer_test/_analyze
{
  "field": "myNormalizerKeyword",
  "text": "Håppy Wørld!!"
}


GET normalizer_test/_analyze
{
  "field": "lowercaseKeyword",
  "text": "Håppy Wørld!!"
}


GET normalizer_test/_analyze
{
  "field": "defaultKeyword",
  "text": "Håppy Wørld!!"
}


PUT normalizer_test/_doc/3
{
  "lowercaseKeyword": "Håppy Wørld!!"
}


GET  normalizer_test/_search?q="happy world!!"


# 한국어 토크나이징
# 띄어쓰기 단위로 복수형, 분사, 동명사 - 변형
# 조사, 감탄사같은 불용어의 처리
# 한자로 되어있는 문자열을 어떻게 처리
# 외래어


GET _analyze
{
  "tokenizer" : "nori_tokenizer",
  "text" :"안녕하세요. 오늘 저녁 날씨가 좋네요. !!!"
}

```